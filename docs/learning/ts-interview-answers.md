# TypeScript Interview Q&A

Этот документ содержит детальные ответы на вопросы по TypeScript, разделенные на:
1.  **Детальное объяснение** (как для джуниора): чтобы полностью понять тему.
2.  **Ответ для клиента/сеньора (Summary)**: краткий, профессиональный ответ, показывающий экспертизу и понимание бизнес-ценности.

---

## 1. Основы TypeScript

### 1.1 Что такое TypeScript и зачем его используют. В чём ключевые отличия от JavaScript?

**Детальное объяснение:**
TypeScript (TS) — это надстройка над JavaScript (JS), разработанная Microsoft. Он добавляет в JS *статическую типизацию*. Браузеры не понимают TS, поэтому перед запуском его нужно превратить (сскомпилировать) обратно в обычный JS.

*Зачем использовать?*
В обычном JS переменные "динамические". Ты можешь положить в переменную число, а потом строку. Это удобно для маленьких скриптов, но в больших проектах это приводит к ошибкам: "undefined is not a function", опечатки в названиях свойств и т.д. TS находит эти ошибки *во время написания кода*, а не когда пользователь уже открыл сайт.

*Ключевые отличия:*
1.  **Типизация**: JS динамически типизирован (типы проверяются при запуске). TS статически типизирован (типы проверяются при написании).
2.  **Компиляция**: TS требует этапа сборки.
3.  **Фичи**: TS поддерживает интерфейсы, дженерики, енамы, которых нет в чистом JS.

**Ответ для клиента/сеньора:**
"TypeScript — это типизированное надмножество JavaScript. Мы используем его, чтобы гарантировать стабильность кода и упростить поддержку проекта. Ключевое отличие в статической типизации: она позволяет отлавливать ошибки на этапе разработки, а не в продакшене, и служит отличной самодокументацией. Для бизнеса это означает: меньше багов, быстрее онбординг новых разработчиков и дешевле поддержка кода в долгосрочной перспективе."

---

### 1.2 Какие преимущества статической типизации?

**Детальное объяснение:**
1.  **Раннее обнаружение ошибок**: Если функция ждет число, а ты передаешь строку, TS подчеркнет это красным сразу же.
2.  **Автодополнение (Intellisense)**: Поскольку редактор знает типы, он может подсказывать методы и свойства. Ты ставишь точку `.` и видишь всё, что доступно.
3.  **Рефакторинг**: Если ты переименовал поле в объекте, TS покажет все места в проекте, где это поле используется, и поможет их обновить. Без типов это был бы поиск "наощупь".
4.  **Читаемость**: Типы говорят, что функция принимает и что возвращает. Тебе не нужно читать тело функции, чтобы понять, как её использовать.

**Ответ для клиента/сеньора:**
"Статическая типизация решает три главные задачи: надежность, скорость разработки и документация. Мы видим ошибки до запуска кода, IDE помогает писать код быстрее благодаря автодополнению, а типы служат живой документацией, которая никогда не устаревает. Это особенно критично на масштабных проектах, где цена ошибки высока."

---

### 1.3 Что такое компилятор tsc и как происходит компиляция TS → JS?

**Детальное объяснение:**
`tsc` (TypeScript Compiler) — это инструмент, который берет файлы `.ts`, проверяет их на ошибки типов и, если всё ок, переписывает их в файлы `.js`. Этот процесс называется *транспиляция* (исходный код в исходный код) или компиляция.
Настройки компиляции лежат в файле `tsconfig.json`. Там мы говорим: "преврати этот современный TS код в старый JS (ES5), чтобы он работал даже в Internet Explorer" или "оставь всё как есть для современных браузеров".

**Ответ для клиента/сеньора:**
"TSC — это компилятор, который транслирует TypeScript в чистый JavaScript, понятный браузерам или Node.js. В процессе он также валидирует типы. Мы настраиваем его через `tsconfig.json`, чтобы контролировать строгость проверок (например, strict mode) и версию выходного JS, обеспечивая баланс между безопасностью кода и поддержкой целевых платформ."

---

### 1.4 Какие есть встроенные типы в TypeScript?

**Детальное объяснение:**
*   **Примитивы**: `number`, `string`, `boolean`, `null`, `undefined`, `symbol`, `bigint`.
*   **`any`**: "Что угодно". Отключает проверку типов. Используй только в крайнем случае.
*   **`unknown`**: "Что угодно, но безопасно". Похож на `any`, но TS заставит тебя проверить тип перед использованием значения.
*   **`void`**: Обычно используется для функций, которые ничего не возвращают (например, `console.log`).
*   **`never`**: Тип значения, которое *никогда* не наступит. Например, функция, которая вечно крутится в `while(true)` или которая всегда выбрасывает ошибку (`throw new Error()`).
*   **`object`**: Любой непримитивный тип.

**Ответ для клиента/сеньора:**
"Помимо стандартных примитивов JS, TypeScript предоставляет важные системные типы для управления потоком данных. Особенно важны `unknown` для безопасной работы с внешними данными (вместо небезопасного `any`) и `void`/`never` для точного описания поведения функций. Грамотное использование этих типов позволяет нам строить предсказуемую логику приложения."

---

### 1.5 Разница между any и unknown

**Детальное объяснение:**
`any` — это "я сдаюсь, делай что хочешь". Если переменная `any`, ты можешь вызвать у неё любой метод, даже несуществующий — TS промолчит, а код упадет в браузере.
`unknown` — это "я не знаю, что здесь, поэтому буду осторожен". Ты можешь положить сюда что угодно, но TS *запретит* делать с ней что-либо, пока ты не докажешь, что это безопасно (через проверку `typeof` или тайп-гарды).

*Пример:*
```typescript
let a: any = 10;
a.smth(); // TS: ОК (Ошибка в рантайме)

let u: unknown = 10;
// u.smth(); // TS: Ошибка! Object is of type 'unknown'.

if (typeof u === 'number') {
    console.log(u.toFixed(2)); // TS: ОК, мы проверили
}
```

**Ответ для клиента/сеньора:**
"`any` полностью отключает проверку типов, что сводит на нет пользу TypeScript. `unknown` — это типизированная альтернатива: он сигнализирует, что тип неизвестен, но заставляет разработчика явно проверить его перед использованием. В нашем коде мы запрещаем `any` (через линтеры) и используем `unknown` для валидации внешних данных, например, ответов API, чтобы исключить падения в рантайме."

---

## 2. Типы, интерфейсы и структуры

### 2.1 Разница между type и interface, когда что использовать

**Детальное объяснение:**
Во многом они похожи и взаимозаменяемы. Оба описывают структуру объекта.
*   **Interface**: Создан специально для описания *объектов*. Их можно расширять (`extends`) и они поддерживают *declaration merging* (если объявить два интерфейса с одним именем, они сольются в один). Обычно используются для написания библиотек или описания классов.
*   **Type**: Более гибкий. Может описывать не только объекты, но и примитивы, объединения (`union`), кортежи (`tuple`). Не сливается автоматически.

*Когда что брать?*
Хорошая практика: используй `interface` для объектов и классов (API контракты, пропсы компонентов). Используй `type` для всего остального (unions, сложные вычисления типов, алиасы примитивов).

**Ответ для клиента/сеньора:**
"Традиционно интерфейсы используются для описания формы объектов и контрактов, которые можно расширять (OOP стиль). Типы (`type`) используются для более сложных композиций: объединений (A или B), пересечений и утилитных типов. В современных проектах мы предпочитаем `type` для строгости и предсказуемости, а `interface` — там, где нужно явное наследование или когда мы пишем публичную библиотеку."

---

### 2.2 Что такое union и intersection types?

**Детальное объяснение:**
*   **Union (`|`)**: "ИЛИ". Переменная может быть одного из нескольких типов.
    `type ID = string | number;` (может быть строкой ИЛИ числом).
*   **Intersection (`&`)**: "И". Объединяет несколько типов в один. Объект должен содержать свойства *обоих* типов.
    `type Draggable = { drag: () => void };`
    `type Resizable = { resize: () => void };`
    `type UIElement = Draggable & Resizable;` (должен иметь И `drag`, И `resize`).

**Ответ для клиента/сеньора:**
"Union types (`|`) позволяют нам моделировать вариативность данных — например, статус может быть 'success' ИЛИ 'error'. Intersection types (`&`) позволяют комбинировать контракты, собирая сложные объекты из простых частей. Это базовые блоки для построения гибкой, но строгой системы типов."

---

### 2.3 Что такое literal types и как они используются?

**Детальное объяснение:**
Обычно тип — это множество значений (например, `string` — любые строки). Literal type — это тип, который равен *конкретному значению*.
Часто используется вместе с Union.
```typescript
type Direction = 'up' | 'down' | 'left' | 'right';
```
Теперь в переменную типа `Direction` можно записать только одно из этих 4 слов. Если напишешь `'forward'`, TS выдаст ошибку.

**Ответ для клиента/сеньора:**
"Literal types позволяют нам ограничивать значения переменных конкретными константами, а не просто типами данных (как string). Это критически важно для конфигураций, статусов ('pending' | 'done') и пропсов компонентов, так как IDE сразу подсказывает возможные варианты и не дает опечататься."

---

### 2.4 Что такое enum и когда его использовать?

**Детальное объяснение:**
Enum (перечисление) — это способ дать дружелюбные имена набору числовых или строковых значений.
```typescript
enum Role {
  Admin,  // 0
  User,   // 1
  Guest   // 2
}
```
*Проблема Enums*: В отличие от типов, они *остаются* в коде после компиляции (превращаются в реальные JS объекты), что увеличивает банндл. В современном TS сообществе часто советуют использовать **Union of Literal Types** (`type Role = 'Admin' | 'User'`) вместо Enum, так как они проще и полностью исчезают при сборке.

**Ответ для клиента/сеньора:**
"Enum — это именованный набор констант. Мы используем их, когда нужен жесткий список значений, на который мы ссылаемся по имени. Однако, в большинстве случаев мы предпочитаем использовать Union Types (`type Status = 'Open' | 'Closed'`). Они легче, не попадают в итоговый JS-бандл и понятнее читаются при отладке, так как в консоли вы увидите просто строку, а не индекс 0 или 1."

---

### 2.5 Что такое tuple и чем он отличается от массива?

**Детальное объяснение:**
Массив (`Array`) — это список элементов *одного* типа любой длины (например, `number[]`).
Tuple (Кортеж) — это массив *фиксированной длины*, где мы знаем тип каждого элемента на конкретной позиции.
```typescript
// Massiv
let arr: number[] = [1, 2, 3, 4, 5];

// Tuple
let user: [string, number] = ["Alice", 25]; // Только так: строка, потом число.
```
Часто используется в React хуках: `const [state, setState] = useState(...)`.

**Ответ для клиента/сеньора:**
"Tuple — это массив с фиксированной структурой, где важен порядок элементов и их типы. Классический пример — CSV строка или React хуки. В отличие от обычных массивов, Tuple гарантирует, что на первой позиции всегда будет, например, ID (число), а на второй — Имя (строка), что добавляет строгости при работе с парами значений."

---

## 3. Продвинутые типы

### 3.1 Объясните generics и их практическое использование

**Детальное объяснение:**
Generic (Дженерик) — это "переменная для типа". Он позволяет писать код, который работает с *разными* типами данных, не теряя типизацию.
Представь функцию, которая возвращает то, что ей передали.
Без дженерика: `function echo(arg: any) { return arg; }` — мы теряем тип, возвращается `any`.
С дженериком: `function echo<T>(arg: T): T { return arg; }`.
Если мы передадим строку, `T` станет `string`. Если число — `T` станет `number`.

*Практика:*
Часто используется в функциях для работы с API (ответ может быть разным), в компонентах (пропсы могут быть разными) и в утилитах.
```typescript
interface ApiResponse<Data> {
  status: number;
  data: Data; // Data подставится в момент использования
}
```

**Ответ для клиента/сеньора:**
"Generics позволяют нам писать переиспользуемый код, сохраняя строгую типизацию. Это ключевой инструмент для создания гибких компонентов и утилит, которые работают с различными типами данных, не прибегая к `any`. Например, мы используем их для типизации оберток над API-запросами, чтобы каждый эндпоинт возвращал строго типизированный ответ, а не просто JSON."

---

### 3.2 Что такое discriminated unions и как их эффективно применять?

**Детальное объяснение:**
Это специальный вид Union типов, где каждый вариант имеет *общее поле* (дискриминант), по которому TS может точно определить, какой именно это тип.
Обычно это поле `type` или `kind`.

*Пример (API ответы):*
```typescript
type Success = { status: 'success'; data: string };
type Error = { status: 'error'; message: string };
type Response = Success | Error;

function handle(res: Response) {
  if (res.status === 'success') {
    console.log(res.data); // TS знает, что здесь есть data
  } else {
    console.log(res.message); // TS знает, что здесь есть message
  }
}
```
Без поля `status` TS бы ругался, что у `Success` нет поля `message`.

**Ответ для клиента/сеньора:**
"Discriminated Unions — это паттерн для работы с вариативными структурами данных. Мы добавляем общее поле-метку (например, `status`), по которому TypeScript автоматически сужает тип. Это идеально подходит для обработки состояний UI (Loading/Success/Error) или ответов бэкенда, гарантируя, что мы никогда не обратимся к данным, которых в текущем состоянии не существует (например, к `user` при ошибке загрузки)."

---

### 3.3 Utility types (Pick, Omit, Partial, Required, Readonly и др.)

**Детальное объяснение:**
Это встроенные инструменты для трансформации типов, чтобы не дублировать код.
*   `Partial<T>`: Делает все поля необязательными.
*   `Required<T>`: Делает все поля обязательными.
*   `Readonly<T>`: Запрещает менять поля.
*   `Pick<T, 'key'>`: Берет из типа T только указанные ключи.
*   `Omit<T, 'key'>`: Берет всё, *кроме* указанных ключей.
*   `ReturnType<T>`: Получает тип, который возвращает функция.
*   `Awaited<T>`: "Распаковывает" Promise (получает тип результата промиса).

**Ответ для клиента/сеньора:**
"Utility types нужны для соблюдения принципа DRY (Don't Repeat Yourself) в типах. Вместо того чтобы создавать 5 похожих интерфейсов (User, UserUpdate, UserPreview), мы создаем один основной `User` и с помощью `Pick`, `Omit` или `Partial` генерируем остальные. Это упрощает рефакторинг: изменили поле в основном типе — оно автоматически обновилось везде."

---

### 3.4 Что такое conditional types и как они работают?

**Детальное объяснение:**
Это "тернарный оператор" для типов.
Синтаксис: `T extends U ? X : Y`.
"Если тип T совместим с U, то выбираем тип X, иначе Y".

*Пример:*
`type IsString<T> = T extends string ? true : false;`
Если передать `string`, будет `true`. Если `number` — `false`.
Часто используется внутри библиотек и сложных утилит, например, чтобы вытащить тип ошибки или данных в зависимости от входных параметров.

**Ответ для клиента/сеньора:**
"Conditional types позволяют создавать 'умные' типы, которые меняются в зависимости от входных данных. Это продвинутая фича, которую мы используем для создания гибких API и утилит, способных автоматически выводить возвращаемый тип на основе аргументов функции, избавляя разработчика от ручного кастинга типов."

---

### 3.5 Что делает оператор keyof и typeof в контексте типов?

**Детальное объяснение:**
*   **`keyof`**: Берет все ключи объекта и создает из них Union тип.
    `type User = { id: number; name: string };`
    `type Keys = keyof User; // "id" | "name"`
*   **`typeof`**: В JS `typeof` возвращает строку ('string', 'object'). В TS, если использовать его *при объявлении типа*, он берет тип переменной.
    `const settings = { theme: 'dark' };`
    `type Settings = typeof settings; // { theme: string }`
    Очень удобно, чтобы не писать интерфейс вручную, если уже есть объект конфигурации.

**Ответ для клиента/сеньора:**
"`keyof` позволяет нам безопасно ссылаться на свойства объектов, гарантируя, что мы не опечатаемся в названии поля. `typeof` позволяет генерировать типы напрямую из JS-кода (например, из конфигов), что сокращает дублирование. Вместе они позволяют писать код, который автоматически подстраивается под изменения в структурах данных."

---

## 4. Язык и синтаксис

### 4.1 Как работают type guards и narrowing?

**Детальное объяснение:**
TS параноик. Если переменная может быть `string | number`, он не даст использовать методы строки. Нам нужно *сузить* (narrow) тип.
Type Guard (Защитник типа) — это конструкция, которая говорит TS: "Проверь, если это строка, то внутри этого блока считай её строкой".
*Встроенные гарды:* `typeof`, `instanceof`, `in`, проверка на равенство (`===`).
*Кастомные гарды:* Функция, возвращающая `arg is Type`.
```typescript
function isCat(pet: any): pet is Cat {
  return (pet as Cat).meow !== undefined;
}
```

**Ответ для клиента/сеньора:**
"Narrowing — это процесс уточнения типа переменной в конкретном блоке кода. Мы используем Type Guards (например, проверки `typeof` или пользовательские функции-предикаты `is...`), чтобы безопасно работать с данными неизвестного или смешанного типа. Это основа безопасного кода: мы сначала проверяем данные, и только потом работаем с ними."

### 4.2 Что такое assertion types и когда они нужны?

**Детальное объяснение:**
Иногда ты знаешь о типе больше, чем TS.
`as` — это способ сказать TS: "Заткнись, я знаю, что делаю. Считай это числом".
`const input = document.getElementById('foo') as HTMLInputElement;` — мы уверены, что элемент там есть и это инпут.
*Опасность:* Если ты ошибешься, TS не поможет, и код упадет в рантайме. Используй только когда TS объективно не может знать контекст (например, DOM).

**Ответ для клиента/сеньора:**
"Type Assertions (`as`) — это механизм ручного переопределения типа. Мы стараемся избегать их, так как они отключают проверки компилятора и переносят ответственность на разработчика. Есть лишь редкие сценарии, где они оправданы — например, при работе с внешними библиотеками с плохой типизацией или при взаимодействии с DOM, где мы точно знаем наличие элемента."

### 4.3 Что такое декораторы и где их используют?

**Детальное объяснение:**
Декораторы — это функции, которые могут "модифицировать" классы, методы или свойства. Они выглядят как `@Component`, `@Injectable`.
Это экспериментальная фича (нужно включать в tsconfig), но она — основа фреймворков вроде Angular и NestJS.
В чистом React/Frontend проекте используются редко. В тестирование (Playwright) могут использоваться для метаданных.

**Ответ для клиента/сеньора:**
"Декораторы — это паттерн метапрограммирования, позволяющий декларативно добавлять поведение к классам. Они являются стандартом в Enterprise-фреймворках типа Angular или NestJS для внедрения зависимостей и настройки модулей. В наших проектах мы можем их встретить, например, при использовании библиотек для валидации данных (`class-validator`) или в тестовых фреймворках."

### 4.4 Что такое mapped types и когда они полезны?

**Детальное объяснение:**
Это способ создать новый тип, "пробежавшись" по ключам другого типа (как `map` у массивов, только для типов).
```typescript
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};
```
Здесь мы берем каждый ключ `P` из типа `T` и делаем его `readonly`. Большинство Utility Types (Partial, Required) сделаны именно через Mapped Types.

**Ответ для клиента/сеньора:**
"Mapped Types — это мощный инструмент для трансформации существующих типов. Они позволяют нам программно изменять свойства объектов — например, сделать все поля необязательными для формы редактирования или добавить всем методам возможность возвращать Promise. Это предотвращает дублирование кода при описании схожих структур данных."

---

## 5. Практика кода и архитектура

### 5.1 Как типизировать API-запросы и гарантировать безопасность?

**Детальное объяснение:**
API возвращает `json`, который по умолчанию `any`. Это опасно.
1.  Создай интерфейс для ответа: `interface UserResponse { id: number; name: string }`.
2.  Используй дженерик в функции запроса: `axios.get<UserResponse>('/user')`.
3.  Но это **не гарантирует**, что сервер вернет именно это! TS проверяет только код, а не рантайм.
4.  Для полной безопасности используй **Zod** или **io-ts**. Это библиотеки, которые проверяют данные в рантайме и одновременно дают TS-тип.

**Ответ для клиента/сеньора:**
"Мы не должны 'слепо' верить бэкенду. Хотя мы описываем контракты через интерфейсы для удобства разработки, в критических местах я использую рантайм-валидацию (с помощью схем типа Zod). Это гарантирует, что если API изменит формат данных, наше приложение не упадет с непонятной ошибкой, а корректно обработает несоответствие схемы."

### 5.2 Как написать типобезопасный generic utility (например, useFetch<T>())?

**Детальное объяснение:**
```typescript
async function useFetch<T>(url: string): Promise<T> {
  const response = await fetch(url);
  const data = await response.json();
  return data as T; // Мы "обещаем" TS, что это T
}

// Использование
const user = await useFetch<User>('/api/user');
```
Важно понимать, что `as T` здесь — это просто обещание. Если сервер вернет что-то другое, TS этого не поймает.

**Ответ для клиента/сеньора:**
"При написании generic-утилит мы используем параметры типа `<T>`, чтобы вызывающий код мог специфицировать ожидаемую структуру. Это делает утилиту универсальной. Однако, я всегда напоминаю команде, что кастинг `as T` внутри утилиты перекладывает ответственность за валидацию данных на нас, поэтому для публичных API лучше внедрять схему валидации."

### 5.3 Как типизировать deeply nested структуры/объекты?

**Детальное объяснение:**
Не пиши один огромный интерфейс на 100 строк. Разбей его на части.
```typescript
interface Address { city: string; zip: string; }
interface Company { name: string; address: Address; }
interface User { id: number; company: Company; }
```
Если нужно "достучаться" до типа глубоко внутри, можно использовать Indexed Access Type:
`type City = User['company']['address']['city']; // string`

**Ответ для клиента/сеньора:**
"Ключ к работе со сложными структурами — декомпозиция. Мы разбиваем огромные JSON-объекты на мелкие, переиспользуемые интерфейсы. Это упрощает чтение и позволяет переиспользовать части структуры (например, тип `Address`) в других местах приложения. Если нужно извлечь тип из глубины существующей структуры, мы используем Lookup Types."

### 5.4 Как enforce immutability через типы (Readonly, const assertions)?

**Детальное объяснение:**
1.  `Readonly<T>`: делает поля недоступными для записи.
2.  `ReadonlyArray<T>`: массив, в который нельзя пушить.
3.  `const result = { name: 'Alice' } as const` (Const Assertion).
    Это делает объект полностью `readonly`, а все строки становятся literal types (не `string`, а `'Alice'`).

**Ответ для клиента/сеньора:**
"Иммутабельность снижает количество багов, связанных со случайным изменением состояния. Мы активно используем модификатор `readonly` и `as const` assertions, особенно для конфигурационных объектов и Redux-состояний. Это заставляет TypeScript выдавать ошибку при любой попытке мутировать данные, гарантируя предсказуемость потока данных."

---

## 6. Инструменты, сборка и разработка

### 6.1 Как настроить tsconfig.json и важные флаги

**Детальное объяснение:**
Самый важный файл.
*   `noImplicitAny: true` — запрещает переменные без типа (если TS не может угадать).
*   `strictNullChecks: true` — `null` и `undefined` не присваиваются автоматически всем типам. Нужно писать `string | null` явно.
*   `strict: true` — включает все строгие проверки. **Всегда включать на старте.**
*   `target`: В какую версию JS компилировать (ES5 для старых, ES2020 для новых).

**Ответ для клиента/сеньора:**
"В продакшене мы всегда используем режим `strict: true`. Это включает `noImplicitAny` и `strictNullChecks`, что предотвращает 80% типичных ошибок 'undefined is not an object'. Мы также настраиваем `target` и `lib` под конкретную среду исполнения (браузер или Node.js), чтобы генерировать оптимальный код без лишних полифилов."

### 6.2 Что такое source maps и зачем они нужны?

**Детальное объяснение:**
Браузер выполняет JS, а не TS. Если ошибка произойдет в строке 100 файла `app.js`, как ты поймешь, где это было в твоем `app.ts`?
Source Map (`.js.map`) — это файл-шпаргалка, которая говорит браузеру: "Строка 100 в JS соответствует строке 50 в TS".
Благодаря этому в DevTools ты видишь свой оригинальный TS код.

**Ответ для клиента/сеньора:**
"Source Maps критически важны для отладки. Они мапят скомпилированный, часто минифицированный JavaScript код обратно на исходный TypeScript. Это позволяет разработчикам видеть в консоли браузера не 'кашу' из машинно-генерируемого кода, а свои реальные файлы, что ускоряет поиск и исправление багов в разы."

### 6.3 Как типизировать сторонние библиотеки без .d.ts?

**Детальное объяснение:**
Если библиотека старая и не имеет типов (`@types/lib-name` нет в npm):
1.  Создай файл `declarations.d.ts`.
2.  Напиши `declare module 'library-name';`.
    Это скажет TS: "Считай, что этот модуль существует и у него тип `any`".
3.  Или напиши `declare module 'library-name' { export function fool(): void; }` (опиши вручную то, что используешь).

**Ответ для клиента/сеньора:**
"В экосистеме TS сейчас почти все библиотеки имеют типы. Если попадается редкий случай без типов, мы не блокируемся: мы создаем файл деклараций `.d.ts` и описываем только те методы, которые реально используем. Это позволяет нам безопасно интегрировать любую JS-библиотеку, сохраняя строгую типизацию в остальной части проекта."

### 6.4 Стратегия миграции с JS на TS

**Детальное объяснение:**
Не переписывай всё сразу!
1.  Настрой `tsconfig` с `allowJs: true` (разрешить JS файлы).
2.  Выбери маленькие, независимые файлы (утилиты). Переименуй `.js` в `.ts`.
3.  Исправь ошибки типов (сначала можно ставить `any`, потом уточнять).
4.  Включи `noImplicitAny` только когда большая часть проекта переписана.

**Ответ для клиента/сеньора:**
"Мы используем инкрементальный подход. Включаем `allowJs`, чтобы TS и JS работали вместе. Затем постепенно переводим файл за файлом, начиная с общей логики и утилит, двигаясь к UI компонентам. Это позволяет не останавливать разработку фич: новые модули пишутся сразу на TS, а старые рефакторятся по мере необходимости (Boy Scout Rule)."

### 6.5 Инструменты (ESLint, Prettier)

**Детальное объяснение:**
*   **ESLint**: Ищет логические ошибки и нарушения стиля (например, "переменная объявлена, но не используется"). Для TS нужен плагин `@typescript-eslint`. (`TSLint` мертв).
*   **Prettier**: Отвечает ТОЛЬКО за форматирование (отступы, запятые, кавычки).
*   Используй их вместе! ESLint ловит баги, Prettier делает код красивым.

**Ответ для клиента/сеньора:**
"Мы используем стандартную связку: ESLint для контроля качества кода и отлова ошибок, и Prettier для автоматического форматирования. Это снимает споры о стиле кода на ревью — всё форматируется автоматически при сохранении. Для TypeScript мы обязательно подключаем `@typescript-eslint` правила, чтобы ловить специфичные для типов проблемы, например, злоупотребление `any`."

---

## 7. Architectural & Senior-Level Concepts

### 7.1 Какие паттерны проектирования помогают писать масштабируемый TS код?

**Детальное объяснение:**
*   **Factory**: Для создания объектов без привязки к конкретным классам.
*   **Adapter**: Для типизации старого JS кода или внешних API под наши интерфейсы.
*   **Decorator**: Для мета-программирования и DI (в NestJS/Angular).
*   **Strategy**: Для подмены алгоритмов (например, разные стратегии валидации форм).
*   **Repository/Service Layer**: Отделение логики работы с данными от UI.

**Ответ для клиента/сеньора:**
"В TypeScript я активно использую паттерны, которые усиливают типизацию. Например, паттерн `Strategy` позволяет мне заменять реализации алгоритмов, сохраняя общий интерфейс. `Repository` позволяет изолировать работу с API, возвращая строго типизированные модели данных, а не сырой JSON. Также часто использую `Discriminated Unions` как замену паттерну `State` для управления сложной логикой переходов состояний."

### 7.2 Как спроектировать систему типов для огромного домена?

**Детальное объяснение:**
1.  **Shared Library**: Выноси общие типы (DTO, Enum) в отдельный пакет (монорепозиторий), который импортят и бэкенд, и фронтенд.
2.  **Code Generation**: Генерируй типы TS автоматически из Swagger/OpenAPI спецификации бэкенда. Не пиши их руками!
3.  **Opaque Types** (Branded Types): Чтобы случайно не передать `UserId` в функцию, которая ждет `OrderId`, хотя оба они — `string`.
    `type UserId = string & { __brand: "UserId" };`

**Ответ для клиента/сеньора:**
"Для крупных доменов критически важен 'Single Source of Truth'. Я настраиваю автоматическую генерацию TypeScript-типов из OpenAPI/Swagger спецификаций бэкенда. Это гарантирует, что фронтенд всегда синхронизирован с API. Также я использую Branded Types для идентификаторов (чтобы случайно не передать ID пользователя вместо ID заказа) и разбиваю типы на доменные области (Namespaces), чтобы избежать конфликтов имен."

### 7.3 Как оценивать производительность компиляции и оптимизировать её?

**Детальное объяснение:**
Если `tsc` работает медленно:
1.  Запусти `tsc --diagnostics`, чтобы увидеть время.
2.  Используй `tsc --generateTrace`, чтобы найти "тяжелые" типы.
3.  **Project References**: Разбей проект на подпроекты (части), чтобы TS пересобирал только то, что изменилось.
4.  Избегай огромных Union Types и чрезмерно глубоких выводов типов.

**Ответ для клиента/сеньора:**
"Скорость CI/CD напрямую зависит от скорости компиляции. Я использую флаг `--incremental` для ускорения локальной сборки и Project References для разбиения монолита на логические части, которые компилируются независимо. Если возникают узкие места, я профилирую компилятор, чтобы найти и упростить переусложненные рекурсивные типы."

---

## 8. Автоматизация (Automation Skills)

### 8.1 Как писать типобезопасные тесты в Playwright?

**Детальное объяснение:**
Playwright из коробки поддерживает TS.
1.  **Page Objects**: Описывай страницы как классы с типизированными методами.
    `class LoginPage { async login(user: UserCredentials) { ... } }`
2.  **Fixtures**: Самое мощное. Ты можешь расширить стандартный объект `test`, добавив туда свои страницы и данные с полной типизацией.
3.  **Config**: Типизируй конфиг через `defineConfig`.

**Ответ для клиента/сеньора:**
"Я использую Page Object Model (POM) в связке с нативными фикстурами Playwright. Это позволяет мне инжектить страницы и сервисы прямо в тест: `test('login', async ({ loginPage }) => { ... })`. Благодаря TypeScript, IDE подсказывает все методы `loginPage`, а если я изменю сигнатуру метода в классе страницы, я сразу увижу ошибки во всех тестах, которые его используют. Это делает рефакторинг тестов дешевым и безопасным."

### 8.2 Как организовать структуру тестов и переиспользуемые утилиты?

**Детальное объяснение:**
(Основано на principles)
Разделяй слои:
1.  **Tests**: Только сценарий ("Что делаем"). Никаких селекторов.
2.  **Steps/Workflows**: Бизнес-шаги ("Оформить заказ"). Объединяют несколько страниц.
3.  **Pages**: Техническая реализация ("Кликнуть кнопку").
4.  **API Services**: Отдельный слой для подготовки данных через API.

**Ответ для клиента/сеньора:**
"Я следую принципу разделения ответственности. Тесты описывают бизнес-сценарии декларативно. Логика взаимодействия с UI инкапсулирована в Page Objects. Сложные флоу (например, 'создать пользователя и заказ') вынесены в Step Classes или API-сервисы. Это позволяет мне создавать данные через API за секунды, а в UI тесте проверять только целевое действие, что ускоряет прогон в разы и делает тесты стабильными."

### 8.3 Как типизировать и валидировать данные из внешних API в автоматизации?

**Детальное объяснение:**
В автотестах мы часто подготавливаем данные через API (Data Seeding).
1.  Опиши интерфейсы запросов (Request) и ответов (Response) для API-клиента.
2.  Используй общий `APIRequestContext` Playwright, обернутый в типизированные методы:
    `async createUser(dto: CreateUserDto): Promise<UserResponse>`.
3.  Валидируй схему ответа в самом тесте, если это API-тест.

**Ответ для клиента/сеньора:**
"Я отношусь к коду автотестов так же серьезно, как к продакшен-коду. У меня есть типизированный API-клиент (Service Layer), который дублирует контракты бэкенда. Это позволяет мне создавать тестовые данные (Preconditions) строго типизированным способом. Если API бэкенда меняется, TS показывает мне ошибки компиляции в моих тестах еще до их запуска, что экономит кучу времени на дебаг."

### 8.4 Как типизировать custom commands / helpers?

**Детальное объяснение:**
В Playwright мы не расширяем глобальный объект (как в Cypress `cy.myCommand`), а используем **Fixtures**.
Мы расширяем тип фикстур:
```typescript
type MyFixtures = {
  db: DatabaseHelper;
  api: ApiClient;
};
export const test = base.extend<MyFixtures>({ ... });
```
Теперь в каждом тесте `db` и `api` строго типизированы.

**Ответ для клиента/сеньора:**
"Вместо 'магических' глобальных команд я использую механизм Dependency Injection через фикстуры Playwright. Я описываю интерфейс фикстур, реализую их и подключаю к тесту. Это дает полную типобезопасность: набрав `db.`, я вижу методы `createUser`, `cleanDb` и знаю, какие аргументы они принимают. Это снижает порог входа для новых QA-инженеров — система сама 
### 8.5 Как совместить типизацию c фикстурами и CI/CD?

**Детальное объяснение:**
Типизация — это первый шаг тестов.
1.  **Mocking**: Когда мы мокаем сетевые ответы (`route.fulfill`), мы должны передавать туда объекты, соответствующие интерфейсам API. Иначе тест может работать с неправильными данными.
2.  **CI/CD**: Перед запуском тестов (которые могут идти часами) мы запускаем шаг `Type Check` (команда `tsc --noEmit`).
    Если где-то ошибка типов (например, изменился интерфейс фикстуры), пайплайн упадет за 10 секунд, а не через час.

**Ответ для клиента/сеньора:**
"Мы внедряем проверку типов как отдельный шаг в CI пайплайне перед запуском тестов. Это реализует подход 'Shift Left': мы ловим ошибки интеграции (например, несоответствие моков реальным типам данных) моментально. Кроме того, типизированные фикстуры гарантируют, что состояние теста изолировано и предсказуемо, что критично для стабильности на CI."

### 8.6 Как проектировать фреймворки с сильной типовой защитой?

**Детальное объяснение:**
Главное правило: **"Make invalid state unrepresentable"** (Сделай невалидное состояние невозможным).
1.  Используй **Strict Mode** в `tsconfig`.
2.  Избегай `any` как огня. Настрой ESLint `no-explicit-any`.
3.  Оберни все внешние взаимодействия (API, DB, Config) в типизированные адаптеры.
4.  Используй Zod для валидации того, что приходит извне.

**Ответ для клиента/сеньора:**
"При проектировании фреймворка я строю 'защитный купол' из типов. Фундамент — это строгий конфиг TypeScript и запрет на `any`. Стены — это типизированные контракты для API и БД. Крыша — это рантайм-валидация через Zod. Это превращает большинство логических ошибок в ошибки компиляции, не давая им утечь в ветку `main`."

